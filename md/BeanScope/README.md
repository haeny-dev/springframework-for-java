# 빈 스코프

- 빈 스코프는 빈이 존재할 수 있는 범위를 뜻한다.

#### 싱글톤 스코프
- `@Scope('singleton')`
  

- 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.


#### 프로토타입 스코프

- `@Scope('prototype')`
  

- 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다.


- 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다.


- 핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것이다. 
  클라이언트에 빈을 반환하고, 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않는다.
  

- `@PreDestroy` 같은 종료 메서드가 호출되지 않는다.


- 프로토타입 빈을 조회한 클라이언트가 관리해야 한다. 종료 메서드에 대한 호출도 직접 해야한다.


##### 싱글톤 빈과 함께 사용시

- 싱글톤 빈이 내부에서 프로토 타입 빈을 사용하면 싱글톤 빈이 생성되고 의존관계 주입 받을 때 스프링 컨테이너로부터 빈을 주입받아 내부 필드에 보관한다.


- 싱글톤 빈의 메서드가 프로토 타입의 메서드를 호출한다고 했을 때, 싱글톤 빈의 메서드가 여러번 호출되면 그때마다 프로토 타입이 생성되는 것이 아니라 의존관계 주입시에 받았던 프로토타입 빈을 가지고 계속해서 호출한다.


- 프로토타입 빈을 여러 싱글톤 빈에서 주입받는다면, 주입 시점에 각각 새로운 인스턴스를 생성하기 때문에 각각의 싱글톤 빈은 서로 다른 프로토타입 빈을 주입 받는다.


- 프로토타입 빈을 사용할 때마다 새로운 빈을 받고 싶다면 `ObjectProvider` 를 사용하여 프로토타입 빈을 얻어오면 된다.
 `getObject()` 를 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 반환한다. 


- `javax.inject.Provider` 라는 JSR-330 자바 표준을 사용하는 방법도 있다.


#### 웹 스코프 

- 웹 스코프는 웹 환경에서만 동작한다.


- 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리한다. 
  따라서 종료 메서드가 호출된다.
  

- `@Scope('request')`: HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다.


- `@Scope('session')`: HTTP Session과 동일한 생명주기를 가지는 스코프


- `@Scope('application')`: 서블릿 컨텍스트(ServletContext) 와 동일한 생명주기를 가지는 스코프


- `@Scope('websocket')`: 웹 소켓과 동일한 생명주기를 가지는 스코프


- 동시에 여러 HTTP 요청이 오면 정확히 어떤 요청이 남긴 로그인지 구분하기 어렵다. 이럴 때 사용하기 좋다.


- 스프링 애플리케이션을 실행하는 시점에 싱글톤 빈은 생성해서 주입이 가능하지만, request 스코프 빈은 아직 생성되지 않는다.
    이 빈은 실제 고객의 요청이 와야 생성할 수 있다.
  

- `ObjectProvider` 를 사용하면 `ObjectProvider.getObject()` 를 호출하는 시점까지 request 스코프 빈의 생성을 지연할 수 있다.


- `@Scope(value = "request", proxyMode = ScopeProxyMode.TARGET_CLASS)` 를 사용하면 가짜 프록시 클래스를 만들어두고 HTTP request 와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있다.


- 적용 대상이 인터페이스면 `ScopeProxyMode.INTERFACES` 사용


  




