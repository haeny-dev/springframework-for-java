# 싱글톤 컨테이너

> *왜 스프링은 싱글톤으로 빈을 만드는 것일까?*
> *이는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다.*
> *물론 스프링으로 PC 등에서 동작하는 독립형 윈도우 프로그램 같은 걸 개발할 수도 있긴 하지만 실제로는 극히 드물다.*
> *태생적으로 스프링은 엔터프라이즈 시스템을 위해 고안된 기술이기 때문에 서버 환경에서 사용될때 그 가치가 있다.*
> *실제로 스프링은 대부분 서버환경에서 사용된다.*
>
> *&nbsp;&nbsp;&nbsp;*
> *스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다.*
> *또 하나의 요청을 처리하기 위해 데이터 엑세스 로직, 서비스 로직, 비즈니스 로직, 프레젠테이션 로직 등의 다양한 기능을 담당하는 오브젝트들이 참여하는 계층형 구조로 이뤄진 경우가 대부분이다.*
> *비즈니스 로직도 복잡한 경우가 많다.*
>
> *&nbsp;&nbsp;&nbsp;*
> *그런데 매번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다고 생각해보자.*
> *요청 한 번에 5개의 오브젝트가 새로 만들어지고 초당 500개의 요청이 들어오면, 초당 2500개의 새로운 오브젝트가 생성된다.*
> *1분이면 십오만 개, 한 시간이면 9백만 개의 새로운 오브젝트가 만들어진다.*
> *아무리 자바의 오브젝트 생성과 가비지 컬렉션의 성능이 좋아졌다고 한들 이렇게 부하가 걸리면 서버가 감당하기 힘들다.*
>
> *&nbsp;&nbsp;&nbsp;*
> *그래서 엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 일찍부터 사용해왔다.*
> *서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝ㅇ트라고 할 수 있다.*
> *스펙에서 강제하진 않지만, 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다.*
> *서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.*
>
> *- 토비의 스프링, 1장 오브젝트와 의존관계, 1.6 싱글톤 레지스트리와 오브젝트 스코프*

## 싱글톤 패턴

싱글톤 패턴은 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이다. 이렇게 하나만 만들어지는 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근이 가능하다.

### 자바에서 싱글톤을 구현하는 방법

- 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다.


- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 static 필드를 정의한다.


- 스태틱 팩토리 메서드인 `getInstance()` 를 만들고 이 메서드가 최초로 호출되는 시점에서 한번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 스태틱 필드에 저장된다. 또는 스태틱 필드의 초기값으로
  오브젝트를 미리 만들어둘 수도 있다.


- 한번 오브젝트가 만들어지고 난 후에는 `getInstance()` 메서드를 통해 이미 만들어져 스태틱 필드에 저장해둔 오브젝트를 넘겨준다.

### 싱글톤 패턴의 문제점

- 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.


- 의존관계상 클라이언트가 구체 클래스에 의존한다. → DIP 를 위반한다.


- 클라이언트가 구체 클래스에 의존해서 OCP 를 위반할 가능성이 높다.


- 내부 속성을 변경하거나 초기화 하기 어렵다.


- private 생성자를 갖고 있기 때문에 상속할 수 없다. → 다형성을 적용할 수 없다.


- 싱글톤은 테스트하기가 힘들다.

## 싱글톤 관리 컨테이너

> *스프링은 서버환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는 것은 적극 지지한다.*
> *하지만 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러 가지 단점이 있기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.*
> *그것이 바로 싱글톤 레지스트리(singleton registry)다.*
> *스프링 컨테이너는 싱글톤을 생성하고, 관리하고, 공급하는 싱글톤 관리 컨테이너이기도 하다.*
> *싱글톤 레지스트리의 장점은 스태틱 메소드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점이다.*
> *평범한 자바 클래스라도 IoC 방식의 컨테이너를 사용해서 생성과 관계설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다.*
>
> *...(중략)*
>
> *&nbsp;&nbsp;&nbsp;*
> *가장 중요한 것은 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴(싱글톤 패턴은 제외) 등을 적용하는 데 아무런 제약이 없다는 점이다.*
>
> *- 토비의 스프링, 1장 오브젝트와 의존관계, 1.6 싱글톤 레지스트리와 오브젝트 스코프*

## 싱글톤 방식의 주의점

> *싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다.*
> *따라서 상태 관리에 주의를 기울여야 한다.*
> *기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태(stateless) 방식으로 만들어져야 한다.*
>
> *...(중략)*
>
> *&nbsp;&nbsp;&nbsp;*
> *따라서 싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 상태유지(stateful) 방식으로 만들지 않는다.*
>
> *- 토비의 스프링, 1장 오브젝트와 의존관계, 1.6 싱글톤 레지스트리와 오브젝트 스코프*

### 무상태(stateless) 로 설계해야 한다.

- 특정 클라이언트에 의존적인 필드가 있으면 안된다.


- 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.


- 가급적 읽기만 가능해야 한다.


- 요청에 대한 정보나, DB나 서버의 리소스로부터 생성한 정보는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.

## @Configuration 과 싱글톤

```java
@Configuration
public class AppConfig {

    @Bean
    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }

    @Bean
    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }

    @Bean
    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }
}
```

위 코드는 애플리케이션 컨텍스트를 생성할 때 사용되는 설정 클래스다.

해당 코드를 보면 `memberService` 빈을 생성하는 코드에서 `memberRepository()` 가 호출되고,
`orderService` 빈을 생성하는 코드에서 `memberRepository()` 가 또 호출된다.
`memberRepository()` 메서드를 호출하면 `new MemoryMemberRepository()` 가 호출되면서 인스턴스가 2번 생성되는 것처럼 보인다.

### "스프링은 이 문제를 어떻게 해결할까?"

스프링 컨테이너는 싱글톤 레지스트리다. 따라서 스프링 빈이 싱글톤이 되도록 보장해주어야 한다. 그런데 스프링이 자바코드까지 어떻게 하기는 어렵다. 위의 자바 코드를 보면 `MemoryMemberRepository`
인스턴스는 총 3번 생성되어야 하는 것이 맞다. 이 문제를 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용하여 해결한다.

```java
  @Test
  void configurationDeep(){
      ApplicationContext ac=new AnnotationConfigApplicationContext(AppConfig.class);
      AppConfig bean=ac.getBean(AppConfig.class);
  
      System.out.println("bean.getClass() = "+bean.getClass());
  }
```

```shell
출력결과
bean.getClass() = class hello.core.AppConfig$$EnhancerBySpringCGLIB$$c9c658a0
```

순수한 클래스라면 `class hello.core.AppConfig` 라고 출력되어야 한다. 그런데 예상과 다르게 `$$EnhancerBySpringCGLIB$$` 가 붙으면서 다른 클래스임을 알 수 있다. 해당
클래스는 내가 만든 클래스가 아니라 스프링이 CGLIB 이라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고, 그 클래스를 이용하여 스프링 빈으로 등록한
것이다.

그 임의의 다른 클래스가 바로 싱글톤을 보장되도록 해준다. 아마도 내부에는 다음과 비슷한 로직으로 구성되어 있을 것이다.

```java
@Bean
public MemberRepository memberRepository(){
    
    if(memoryMemberRepository가 이미 스프링 컨테이너에 등록되어 있으면?){
        
        return 스프링 컨테이너에서 찾아서 반환;
        
    } else { //스프링 컨테이너에 없으면
        
        기존 로직을 호출해서 MemoryMemberRepository를 생성하고 스프링 컨테이너에 등록 
        return 반환
    }
}
```
### @Configuration 을 적용하지 않는다면 어떻게 될까?

앞서 `@Configuration` 을 적용하면 바이트코드를 조작하는 CGLIB 기술을 사용해서 싱글톤을 보장하는 것을 확인할 수 있었다.
만약 `@Configuration` 을 적용하지 않고, `@Bean` 만 적용하면 어떻게 될까?

결과는 AppConfig 에 대해서 `class hello.core.AppConfig` 라는 CGLIB 기술이 적용되지 않은 빈이 생성된다.
마찬가지로 `@Bean` 에 의해 각각의 메서드가 호출되었고, 싱글톤이 유지되지않은 채 `MemoryMemberRepository` 는 3번 호출 되었고,
각각의 인스턴스가 생성된 것을 확인할 수 있었다.

즉 스프링 설정정보 클래스를 사용할 때는 `@Configuration` 을 사용해야 싱글톤을 보장할 수 있다.


