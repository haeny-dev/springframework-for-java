### 엔티티 설계시 주의점

*엔티티에는 가급적 Setter 를 사용하지 말자*
- Setter 가 모두 열려있다. 변경 포인트가 너무 많아서, 유지보수가 어렵다. 나중에 리펙토링으로 Setter 제거

*모든 연관관계는 EAGER 가 아닌 LAZY 로 설정해야 한다.*
- 하이버네이트에서는 EAGER 에 대해서 계속해서 밀고 있고, 최적화도 해주고 있다.
  - 예를 들어, Order 와 Member 관계에서 Order 를 조회할때 Member 를 EAGER 로 설정해져있다면, 한번에 Member 정보까지 조회해온다.
- 그러나, 문제는 JPQL 을 사용하여 select o from order o; 와 같이 사용할 경우  
  - SQL 로 번역되어 select * from order 로 조회된다.   
  - eager 나 lazy 랑 상관없이 order 가 100건이면 member 를 100번 조회하게 되는 현상이 발생한다.  
  - N + 1 문제   
- 결론, 전부다 지연로딩으로 설정해줘야 한다.
- 연관된 엔티티를 함께 DB 에서 조회해야 한다면, fetch join 또는 엔티티 그래프 기능을 사용한다. 


*컬렉션은 필드에서 초기화 하자*
- 컬렉션은 필드에서 바로 초기화 하는 것이 안전하다.
- 기본적으로 null 문제에서 안전하다.
- 하이버네이트는 엔티티를 영속화 할 때, 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다.
  - 만약 임의의 메서드에서 컬렉션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다.
  - 따라서 필드레벨에서 생성하는 것이 가장 안전하고, 코드도 간결하다.

*테이블, 컬럼명 생성 전략*
- 스프링 부트에서 하이버네이트 기본 매핑 전략을 변경해서 실제 테이블 필드명은 다르다.
  - 하이버네이트 기존 구현
    - 엔티티의 필드명을 그대로 테이블의 컬럼명으로 사용
    - SpringPhysicalNamingStrategy
  
  - 스프링 부트 신규 설정
    - 카멜 케이스 > 언더스코어
    - . (점) > 언더스코어
    - 대문자 > 소문자
  
- 적용 2단계
  - 논리명 생성
    - `spring.jpa.hibernate.naming.implicit-strategy`
    - 명시적으로 컬럼, 테이블명을 직접 적지 않으면 ImplicitNamingStrategy 사용
  
  - 물리명 적용
    - `spring.jpa.hibernate.naming.physical-strategy`
    - 모든 논리명에 적용됨. 실제 테이블에 적용(username -> usernm 등의 회사 룰로 변경 가능)

- order - orderItems, order - delivery 관계에서 cascade 미설정 시
    - persist(orderItemA)
    - persist(orderItemB)
    - persist(orderItemC)
    - persist(delivery)
    - persist(order)
    
- CascadeType.ALL 설정 시
    - persist(order)
  

*참고*
- [스프링 부트 - 하이버네이트 네이밍 전략](https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-hibernate-naming-strategy)
- [하이버네이트 네이밍 가이드](http://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#naming)
    